## 🧭 一、思维起点：先问自己两个问题

在写代码前，你先想清楚这两个问题👇

| 自问问题                     | 如果答案是 ✅ → 用这个                  |
| ------------------------ | ------------------------------ |
| “我是在传递事件（比如任务之间打招呼）吗？”   | 🟢 **二值信号量（Binary Semaphore）** |
| “我是在保护一个共享资源（比如串口、变量）吗？” | 🔵 **互斥量（Mutex）**              |

> ✅ **简单判断口诀：**
> 🔔 信号量传消息，🔒 互斥量防抢占。

---


## 🧩 二、二值信号量的使用场景（门铃型）

### 📘 1️⃣ 中断唤醒任务

中断里不能直接做复杂操作，于是：

* ISR 里 “Give” 信号量（按门铃）
* 任务里 “Take” 信号量（听铃处理）

```c
// 中断服务函数
void EXTI_IRQHandler(void)
{
    xSemaphoreGiveFromISR(binarySem, NULL); // 通知任务
}

// 任务函数
void Task_Button(void *pvParameters)
{
    for (;;) {
        xSemaphoreTake(binarySem, portMAX_DELAY); // 等待按键
        handle_button_event(); // 处理逻辑
    }
}
```

📖 **生活类比：**

> ISR 是“门口按铃的人”，任务是“听到铃声出来的人”。

---

### 📘 2️⃣ 任务间同步

任务 A 做完事后，通知任务 B 可以开始。

```c
// Task A
xSemaphoreGive(binarySem); // 通知完成

// Task B
xSemaphoreTake(binarySem, portMAX_DELAY); // 等待通知
```

📖 **生活类比：**

> A 说“我准备好了”，B 等信号再开始干。

---

### ✅ **总结：什么时候用二值信号量？**

* 想让一个任务“等一件事发生”；
* 中断要通知任务；
* 两个任务要“先后协作”。

🧠 **关键词：**

> “信号”、“同步”、“通知”，而不是“保护”。

---

## 🧩 三、互斥量的使用场景（钥匙型）

### 📘 1️⃣ 多任务访问共享资源

多个任务都要访问同一个外设（比如 UART、SPI、LCD 等）。
为了防止两个任务同时操作导致数据乱，就要加锁。

```c
xSemaphoreTake(uart_mutex, portMAX_DELAY);
uart_send("Hello");
xSemaphoreGive(uart_mutex);
```

📖 **生活类比：**

> 只有拿到钥匙的人才能用设备，用完必须自己还钥匙。

---

### 📘 2️⃣ 避免“优先级反转”

高优先级任务 A 想用 UART；
低优先级任务 B 正在用 UART；
中优先级任务 C 一直在运行；
→ A 被饿死。

如果用 **互斥量**：
系统会自动让 B **临时提高优先级**，
用完后再降回去 —— 这叫“优先级继承”。

📘 这就是为什么保护资源时要用 Mutex，不要用 Binary Semaphore！

---

### 📘 3️⃣ 同一任务嵌套调用（递归互斥量）

有时一个任务在函数 A 里加锁，又在函数 B（被 A 调）里再加锁。
这时要用 **递归互斥量（Recursive Mutex）**。

---

### ✅ **总结：什么时候用互斥量？**

* 共享资源只能一个人用；
* 希望系统自动处理优先级反转；
* 同一个任务会反复进入临界区。

🧠 **关键词：**

> “保护”、“独占”、“优先级继承”、“必须自己解锁”。
