## 为什么寄存器要 volatile？

寄存器不是普通变量，它可能被“硬件自己改”（状态位）、被中断改、被 DMA 改。
如果不加 volatile，编译器可能：
- 只读一次寄存器，然后一直用缓存值
- 合并/删除你以为必须发生的读写
结果：轮询可能卡死，或者读不到最新状态。

## 一句话结论
**MMIO（内存映射寄存器）必须 volatile**，保证每次访问都真的去读/写那个地址。

## 快速例子（伪代码）
错误：
while ((REG & READY)==0) {}  // REG 不 volatile 可能被缓存，死循环

正确：
while ((VREG & READY)==0) {} // VREG volatile，每次都读硬件

## 检查（自问）
- volatile 能不能保证多线程/中断下原子性？（提示：不能）
- volatile 能不能当内存屏障？（提示：通常不等价）
