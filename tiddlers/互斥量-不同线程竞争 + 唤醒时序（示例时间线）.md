[[优先级反转]]

[[优先级继承]]

不同线程竞争 + 唤醒时序（示例时间线）

设：线程 `T1` 先获取互斥量，随后高优线程 `T2` 来抢。

1. `T1`：`rt_mutex_take(m, WAIT_FOREVER)` → 成功，`owner=T1, hold=1`。
2. `T2`：`rt_mutex_take(m, WAIT_FOREVER)` → 发现被占用，入 `m.wait_list`；
   - 若 `prio(T2)` 高于 `prio(T1)`，触发[[优先级继承]]：**临时把 `T1` 的优先级提高到 `prio(T2)`，使 `T1` 更快运行、尽快释放互斥量。`T2` 挂起等待。**
3. `T1`：完成临界区后 `rt_mutex_release(m)`：
   - `hold` 递减至 0；等待队列非空 → 选择最高优先级等待者 `T2`，**内核直接把 owner 切给 `T2`**、`hold=1`；
   - 恢复 `T1` 的优先级到 `original_priority`；
   - 唤醒 `T2`。
4. `T2` 被调度运行后，已经“拿着锁”，可立即进入临界区执行。


整个过程中，**互斥访问**依靠 `owner` 的唯一性和等待队列保证，同一时刻仅有一个线程进入受保护临界区；

**唤醒**由释放路径触发，且伴随所有权转移；**优先级继承**避免了高优线程被低优线程“间接阻塞”。