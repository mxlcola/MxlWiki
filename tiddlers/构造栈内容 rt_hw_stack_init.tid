created: 20250820144131261
modified: 20250820144408234
tags: SP ?
title: 构造栈内容 rt_hw_stack_init

!! 构造栈内容 rt_hw_stack_init()

* 调用 CPU 架构相关的 rt_hw_stack_init()，为该线程构造一次“伪上下文”：

**模拟线程第一次执行时 CPU 寄存器的状态。

**设置 PC = 线程入口函数地址。

**设置 LR = 线程退出时调用的清理函数，例如 rt_thread_exit。

** 栈顶指针位置对齐，并把初始寄存器内容压栈。

```c
thread->sp = (void *)rt_hw_stack_init(....)
```

```c
rt_uint8_t *rt_hw_stack_init(void       *tentry,
                             void       *parameter,
                             rt_uint8_t *stack_addr,
                             void       *texit)
{
    struct stack_frame *stack_frame;
    rt_uint8_t         *stk;
    unsigned long       i;

    stk  = stack_addr + sizeof(rt_uint32_t);
    stk  = (rt_uint8_t *)RT_ALIGN_DOWN((rt_uint32_t)stk, 8);
    stk -= sizeof(struct stack_frame);

    stack_frame = (struct stack_frame *)stk;

    /* init all register */
    for (i = 0; i < sizeof(struct stack_frame) / sizeof(rt_uint32_t); i ++)
    {
        ((rt_uint32_t *)stack_frame)[i] = 0xdeadbeef;
    }

    stack_frame->exception_stack_frame.r0  = (unsigned long)parameter; /* r0 : argument */
    stack_frame->exception_stack_frame.r1  = 0;                        /* r1 */
  ....                     
    stack_frame->exception_stack_frame.lr  = (unsigned long)texit;     /* lr */
    stack_frame->exception_stack_frame.pc  = (unsigned long)tentry;    /* entry point, pc */
    stack_frame->exception_stack_frame.psr = 0x01000000L;              /* PSR */

    /* return task's current stack address */
    return stk;
}

```