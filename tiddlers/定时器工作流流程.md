

1. **核心全局变量**

   * `rt_tick`：系统时钟节拍计数器，每次硬件定时器中断来临时自增 1。
   * `rt_timer_list`：所有激活定时器按“绝对超时时刻”排序后的跳表/链表容器。

2. **定时器创建与激活**

   * 用户调用创建／启动接口时，填写：

     * `init_tick`：相对延迟（比如 50 tick）。
     * `timeout_tick = rt_tick + init_tick`：计算出“绝对到点时刻”。
     * 回调函数 `timeout_func` 及其参数。
   * 将该定时器节点插入到 `rt_timer_list` 中，保持全局有序。

3. **系统时钟中断驱动**

   * 硬件定时器每隔 OS Tick（如 10ms）触发一次中断。
   * 中断处理函数里，只做两件事：

     1. `rt_tick++`；
     2. 检查链表最前端的定时器：若其 `timeout_tick == rt_tick`，则把它取出并触发回调。

4. **超时回调执行**

   * **HARD\_TIMER 模式**（默认）：回调在中断上下文执行，必须“快、短、不阻塞”。
   * **SOFT\_TIMER 模式**（可选）：回调在专门的 timer 线程中执行，允许较重的操作，但仍需注意优先级。

5. **定时器清理与重载**

   * **一次性定时器**：触发后回调执行完成，直接销毁／从链表移除。
   * **周期定时器**：触发后，将 `timeout_tick += init_tick` 重新计算下一个触发时刻，再次插入到链表中。

6. **中途插入新定时器**

   * 任何时刻，当有新定时器启动（或周期定时器重载）时，都按照新的 `timeout_tick` 找到链表中对应位置插入，保持有序。

7. **跳表加速查找**

   * 对于链表节点数目多的场景，RT-Thread 支持多级跳表（`RT_TIMER_SKIP_LIST_LEVEL`）来加快“定位下一个要触发的节点”这一查找过程，时间复杂度从 O(n) 降到 O(log n)。

---
。
