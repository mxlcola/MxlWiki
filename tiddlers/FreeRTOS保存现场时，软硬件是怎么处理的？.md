关联卡片：

[[现场寄存器软硬件处理]]

## PSP和MSP的区别

- **Cortex-M 任务在“线程态(Thread mode)”运行，使用 [[PSP]]（Process Stack Pointer，[[进程栈]]）。**
- **异常处理（比如 SysTick、PendSV、SVC）在“处理态(Handler mode)”运行，使用 [[MSP]]（Main Stack Pointer，主栈）。**


## Q:硬件做了什么？软件做了什么？

**硬件在异常入口自动做（入栈到 PSP）：**

- 压入：`r0, r1, r2, r3, r12, lr, pc, xPSR`
- 切换到 **MSP** 执行异常代码
- 退出异常时（`bx r14`），自动从 PSP 弹出同样那一组寄存器

**软件（这段汇编）做：**

- 读取 PSP，**手动压入/弹出 r4–r11** 到任务栈（PSP 指向的栈）
- 把更新后的 **PSP 写回/读出 TCB**（任务的“栈顶指针”就是上下文的锚点）
- 用 **BASEPRI** 做临界区保护，调用 `vTaskSwitchContext` 更新 `pxCurrentTCB`
- 设置 **PSP** 指向下一个任务，最后 `bx r14` 交还给硬件完成剩下的恢复

## Q:为什么分工这么做？

- 这样可以让**异常框架的硬件自动入栈/出栈**承担“半包”，简化并加速切换；
- 内核只需补齐 **r4–r11** 和维护 PSP/TCB；
- 当有 **FPU** 时，硬件还支持“惰性堆栈（lazy stacking）”，浮点寄存器在需要时自动入/出栈，汇编也无需改动（这段是“无 FPU 额外保存”的通用版本）。

>一句话：**硬件负责“半包”（r0–r3、r12、lr、pc、xPSR），软件补全另一半（r4–r11），两人搭档把现场完整存/取。**

------

{{现场寄存器软硬件处理}}